"""
    Different (geeky) utils for TA
"""
import os
import subprocess
import shutil
import stat
import pathlib
from easydict import EasyDict as edict
# from jinja2 import Template, Undefined
from jinja2 import Environment, FileSystemLoader, Template, Undefined, DebugUndefined
# from elevate import elevate
import inspect
import re


def fname2stage(fname):
    return re.sub(r'''\d\d\_''', '', fname)

def fname2shname(fname):
    ext = '.bat'
    return 'ta-' + fname.replace('stage_','').replace('_', '-') + ext

def fname2num(fname):
    for m in re.findall(r'''\d\d''', fname):
        return int(m)
    return None

def fname2option(fname):
    return re.sub(r'''_''', '-', fname)


def get_method_name():
    curframe = inspect.currentframe().f_back
    (filename, line_number, function_name, lines, index) = inspect.getframeinfo(curframe)        
    return function_name


def mkdir_p(path):
    pathlib.Path(path).mkdir(parents=True, exist_ok=True)
    pass


def folder_size(path, *, follow_symlinks=False):
    '''
    Counting size of a folder. 
    '''
    try:
        if not os.path.exists(path):
            # Nonexistant folder has zero size.
            return 0
        it = list(os.scandir(path))
        # with os.scandir(path) as it:
        return sum(folder_size(entry, follow_symlinks=follow_symlinks) for entry in it)
    except NotADirectoryError:
        return os.stat(path, follow_symlinks=follow_symlinks).st_size

def wtf(f):
    '''
    For debugging purposes.
    '''
    for wtf_ in ['PYTEST', '/tests']:
        if wtf_ in f:
            return True
        
class NullUndefined(Undefined):
  def __getattr__(self, key):
    return ''        

def yaml_load(filename, vars_=None):
    '''
    Load yaml file into edict. Hide edict deps.
    ''' 
    import yaml

    fc = None
    # with open(filename, 'r') as f:
    dir_, filename_ = os.path.split(os.path.abspath(filename))
    file_loader = FileSystemLoader(dir_)
    env = Environment(loader=file_loader, undefined=DebugUndefined)
    env.trim_blocks = True
    env.lstrip_blocks = True
    env.rstrip_blocks = True            

    def basename(path):
        return os.path.basename(path)

    def dirname(path):
        return os.path.dirname(path)    

    env.filters['basename'] = basename
    env.filters['dirname']  = dirname        

    template = env.get_template(filename_)

    real_yaml = ''
    try:
        for try_ in range(5):
            real_yaml = template.render(vars_)
            #print(real_yaml[:200])
            ld = yaml.safe_load(real_yaml)
            vars_ = {**vars_, **ld}

        # for key in vars_:
        #     if key.endswith('_dir'):
        #         vars_[key] = vars_[key].replace('/', '@')

        real_yaml = template.render(vars_)
        fc = edict(yaml.safe_load(real_yaml))
    except Exception as ex_:
        print(f'Error parsing {filename_} see "troubles.yml" ')    
        with open("troubles.yml", 'w', encoding='utf-8') as lf:
            lf.write(real_yaml)
        raise ex_    
    return fc, vars_



def rmdir(oldpath):
    if os.path.exists(oldpath):
        shutil.rmtree(oldpath, ignore_errors=True)
    if os.path.exists(oldpath):
        os.system('sudo rm -rf "%s"' % oldpath)
    #     elevate(graphical=False)
    #     shutil.rmtree(oldpath)
    pass

def git2dir(git_url, git_branch, path_to_dir):
    oldpath = path_to_dir + '.old'
    newpath = path_to_dir + '.new'
    rmdir(oldpath)
    pdir = os.path.split(path_to_dir)[0]
    os.chdir(pdir)
    scmd = 'git --git-dir=/dev/null clone --single-branch --branch %(git_branch)s  --depth=1 %(git_url)s %(newpath)s ' % vars()
    rmdir(newpath)
    os.system(scmd)
    if os.path.exists(newpath):
        if os.path.exists(path_to_dir):
            rmdir(oldpath)
            shutil.move(path_to_dir, oldpath)
        print(newpath, "->", path_to_dir)    
        shutil.move(newpath, path_to_dir)
    pass

def make_setup_if_not_exists():
    '''
    If python package without setup.py
    (for example Poetry)
    '''
    if not os.path.exists('setup.py') and os.path.exists('setup.cfg'):
        from poetry.masonry.builders.sdist import SdistBuilder
        from poetry.factory import Factory
        factory = Factory()
        poetry = factory.create_poetry('.')                
        sdist_builder = SdistBuilder(poetry, None, None)
        setuppy_blob = sdist_builder.build_setup()
        with open('setup.py', 'wb') as unit:
            unit.write(setuppy_blob)
            unit.write(b'\n# This setup.py was autogenerated using poetry.\n')                
    pass


def giturl2folder(git_url):
    _, fld_ = os.path.split(git_url)
    fld_, _ = os.path.splitext(fld_)
    return fld_


def expandpath(path):
    return os.path.abspath(os.path.expanduser(os.path.expandvars(path)))


import ast

def generate_imports_from_python_file(code, filename):
    """
    Extract import statements from a string containing Python code.

    Generate (i.e. yield) the module names that are imported in the order
    they appear in the code.
    """

    try:
        parsed_code = ast.parse(code, filename=filename)
    except SyntaxError as exc:
        print(f"Could not parse code from {filename}: {exc}")
        return
    
    for node in ast.walk(parsed_code):
        if isinstance(node, ast.Import):
            for alias in node.names:
                name = alias.name.split(".", 1)[0]
                yield name
        elif isinstance(node, ast.ImportFrom):
            # Relative imports are always relative to the current package, and
            # will therefore not resolve to a third-party package.
            # They are therefore uninteresting to us.
            if node.level == 0 and node.module is not None:
                name = node.module.split(".", 1)[0]
                yield name
